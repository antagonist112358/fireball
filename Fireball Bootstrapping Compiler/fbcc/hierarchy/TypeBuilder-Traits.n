using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler.SolverMacros;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Specialized;

using PT = Nemerle.Compiler.Parsetree;
using SCG = System.Collections.Generic;
using SC = System.Collections;

namespace Nemerle.Compiler
{
  /// <summary>
  /// Description of TypeBuilder_Traits.
  /// </summary>
  public partial class TypeBuilder : TypeInfo
  {
    private static MemberPublicBindingFlags = (BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.Static);
    private static InterfaceMethodBindingFlags = (BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.Instance);
    
    internal DoRewriteTraitBody() : void
    {
      match (tydecl)
      {
        | TypeDeclaration.Trait => rewrite_trait_body()
        | _ => ()
      }
    }
    
    private rewrite_trait_body() : void 
    {
      def collect_members_with_implementation() : list[PT.ClassMember.Function]
      {
        GetParsedMembers().FoldLeft([], (memb, acc) => match(memb) {
          | PT.ClassMember.Function(_, _, body) as fnc when !(body is FunBody.Abstract) => fnc :: acc
          | _ => acc
        }).Rev();
      }
      
      def collect_members_without_implementation() : list[PT.ClassMember]
      {
        GetParsedMembers().FoldLeft([], (memb, acc) => match(memb) {
          | PT.ClassMember.Function(_, _, body) when !(body is FunBody.Abstract) => acc
          | other => other :: acc
        }).Rev()
      }
      
      def rewrite_implementation_body(body : FunBody) : FunBody.Parsed
      {
        def refName = PT.PExpr.Ref(PT.Name("self"));
        
        def replace_this(_, is_post, e) {
          if(is_post) {
            match(e) {
              | PT.PExpr.This => refName
              | other => other
            }
          } else e
        };
        
        match(body)
        {
          | Parsed(expr : Parsetree.PExpr) =>
            FunBody.Parsed(Util.locate (expr.Location, {
              Macros.TraverseExpr (None (), expr, false, replace_this)
            }))
          | _ => Util.ice("Tried to rewrite trait method implementation, but got a non-parsed function body. This should not happen. Please report this error to the Fireball team.");
        }        
      }
      
      def create_static_implementation_function(fnc : PT.ClassMember.Function, implName: PT.Splicable, write_attr: bool = true, overwritten: bool = false) : PT.ClassMember.Function
      {
        def default_mods = (NemerleModifiers.Static | NemerleModifiers.Public);
        mutable attribute_mods = ({
          if (fnc.modifiers.mods %&& NemerleModifiers.Protected) [ <[ "protected" ]> ]
          else if (fnc.modifiers.mods %&& NemerleModifiers.Private) [ <[ "private" ]> ]
          else []
        }).ToArray();
        
        def mods = fnc.modifiers.Clone();
        mods.Modifiers = if (overwritten) (default_mods | NemerleModifiers.New) else default_mods;
        
        when(write_attr)
          mods.custom_attrs ::= <[ Fireball.Internal.TraitMethod( ..$attribute_mods ) ]>;
        
        def h = fnc.header;
        def typeName = <[$(this.GetMemType() : typed) ]>;
        def newParam = PT.PParameter(PT.Splicable.Name(PT.Name("self")), AttributesAndModifiers.Empty, typeName);
        // Rewrite the body
        def body = rewrite_implementation_body(fnc.body);
        
        def header = match(h.TypeParameters) {
          | a when a.Equals(PT.Typarms.Empty) => PT.PFunHeader(h.Location, implName, h.ReturnType, newParam :: h.Parameters);
          | typarms => PT.PFunHeader(h.Location, typarms, implName, h.ReturnType, newParam :: h.Parameters);
        };
        
        PT.ClassMember.Function(fnc.Location, implName, mods, header, [], body);
      }

      def is_public(fnc: PT.ClassMember.Function) : bool {
        fnc.modifiers.mods %&& NemerleModifiers.Public || fnc.modifiers.mods == NemerleModifiers.None
      }
      
      def rewrite_implementation_function(fnc: PT.ClassMember.Function, implName : PT.Splicable) : PT.ClassMember.Function
      {        
        def closure_str = implName.GetIdentifier();
        def add_attr_to_mods(mods) {
          mods.custom_attrs ::= <[ Fireball.Internal.DefaultImplementation( $(String.Format("{0}", closure_str)) ) ]>;
          mods
        }
        PT.ClassMember.Function(fnc.Location, PT.Splicable.Name(PT.Name(fnc.Name)), add_attr_to_mods(AttributesAndModifiers.Empty), fnc.header, [], FunBody.Abstract())
      }
      
      when(IsTrait)
      {
        def implementedMembers = collect_members_with_implementation();
        
        when (!implementedMembers.IsEmpty) {
          mutable newMembers = collect_members_without_implementation();
        
          foreach(memb in implementedMembers)
          {
            if (is_public(memb)) {
              def newName = PT.Splicable.Name(PT.Name($"_FB_$(memb.Name)_Impl"));
              newMembers += [create_static_implementation_function(memb, newName, false), rewrite_implementation_function(memb, newName) ];
            } else {
              def newName = PT.Splicable.Name(PT.Name(memb.Name, memb.Location));
              newMembers ::= create_static_implementation_function(memb, newName, true);              
            }
          }
        
          // Add the trait attribute
          this._ast.modifiers.custom_attrs ::= <[ Fireball.Internal.FireballTrait() ]>;
          
          // Rewrite the trait's Ast
          this._ast = PT.TopDeclaration.Trait(this._ast :> PT.TopDeclaration.Trait, newMembers);
        }
      }
      
    }
    
    private add_included_trait_methods() : void
    {
      
      def make_mods(accessWords: list[string], mods) : NemerleModifiers
      {
        match(accessWords) {
          | word :: tail => 
            if (word.ToUpper() == "PROTECTED")
              make_mods(tail, mods | NemerleModifiers.Protected)
            else if (word.ToUpper() == "PRIVATE")
              make_mods(tail, mods | NemerleModifiers.Private)
            else
              make_mods(tail, mods);            
          | _ => mods
        }
      }
      
      def make_call_params_from_typed(header: TFunHeader) : list[PT.PExpr]
      {
        header.Parameters.Map(tp => <[ $(tp.AsParsed().name.GetName() : name) ]>)
      }

      def make_function_args(typed_params: list[TParameter]) : list[PT.PParameter]
      {
        typed_params.Tail.Map(tp => tp.AsParsed())
      }
      
      def make_trait_impl(trait_name: PT.Name, func_name: PT.Splicable, fnc: IMethod, trait_attr: Fireball.Internal.TraitMethodAttribute) : PT.ClassMember.Function
      {
        def mods = make_mods(trait_attr.AccessModifiers.NToList(), NemerleModifiers.None);
        //def header = PT.PFunHeader(fnc.Location, fnc.header.TypeParameters, PT.Name(fnc.Name).MakeSplicable(), fnc.header.ReturnType, fnc.header.Parameters.Tail);
        //def body = FunBody.Parsed(<[ $(trait_name : name) . $(PT.Name(fnc.Name).MakeSplicable()) (this, ..$(header.Parameters) ) ]>);
        def callparms = <[ this ]> :: make_call_params_from_typed(fnc.Header);
        def func_args = make_function_args(fnc.Header.Parameters);
        
        <[decl:
          ..$(AttributesAndModifiers(mods, [])) $func_name (..$func_args ) : $(fnc.Header.ReturnType : typed) {
            $(trait_name : name) . $func_name (..$callparms )
          }
        ]>
      }
      
      def make_default_impl(in_type: TypeInfo, trait_name: PT.Name, func_name: PT.Splicable, default_impl: Fireball.Internal.DefaultImplementationAttribute) 
      {
        match(in_type.GetMembers(MemberPublicBindingFlags).Filter(memb => memb.Name == default_impl.ImplementationName).Map(_ :> IMethod).HeadOption())
        {
          | Some(fnc) =>
            def callparms = <[ this ]> :: make_call_params_from_typed(fnc.Header);
            def func_args = make_function_args(fnc.Header.Parameters);

            Some(<[ decl:
              public virtual $func_name ( ..$func_args) : $(fnc.Header.ReturnType : typed) {
                $(trait_name : name) . $func_name ( ..$callparms )
              }
            ]>)
          | None => 
            Message.Error($"could not find default implementation method for $(trait_name).$(func_name) called $(default_impl.ImplementationName).");
            None()
        }
      }
      
      unless(IsEnum || IsDelegate || IsTrait || IsStruct || IsAlias || IsModule)
      {
        foreach(ifaceTy in InterfacesToImplement().Map(_.TypeInfo))
        {
          when(ifaceTy.IsCustomAttributeDefined("Fireball.Internal.FireballTraitAttribute"))
          {
            def trait_name = LazyValue(() => PT.Name(ifaceTy.FullName));            
            // Go through all the instance members (which might have default implementations)
            foreach(ifaceMeth in ifaceTy.GetMembers(InterfaceMethodBindingFlags).Filter(memb => memb is IMethod && memb.IsCustomAttributeDefined("Fireball.Internal.DefaultImplementationAttribute")).Map(_ :> IMethod))
            {
              def default_attr = get_default_impl_attribute(ifaceMeth);
              def ifaceMethName = PT.Name(ifaceMeth.Name).MakeSplicable();
              match(make_default_impl(ifaceTy, trait_name, ifaceMethName, default_attr))
              {
                | Some(decl) => this.Define(decl)
                | None => ()
              }
            }
            // Go through all the static trait members and look for [TraitMethod] attribute
            foreach(traitMeth in ifaceTy.GetMembers(MemberPublicBindingFlags).Filter(memb => memb is IMethod && memb.IsCustomAttributeDefined("Fireball.Internal.TraitMethodAttribute")).Map(_ :> IMethod))
            {
              def trait_attr = get_trait_method_attribute(traitMeth);
              def traitMethName = PT.Name(traitMeth.Name).MakeSplicable();
              def decl = make_trait_impl(trait_name, traitMethName, traitMeth, trait_attr);
              this.Define(decl);
            }
          }
        }
      }
    }
   
    private get_default_impl_attribute(from: IMethod) : Fireball.Internal.DefaultImplementationAttribute
    {
      match(from.GetModifiers().FindAttribute(Manager.InternalType.DefaultImplementationAttribute_tc, GlobalEnv))
      {
        | Some(expr) => match(expr)
          {
            | <[ $_ ($(str : string))]> => Fireball.Internal.DefaultImplementationAttribute(str)
            | _ => Util.ice("found proper default implementation attribute but then failed to read it.");      
          }
        | _ => Util.ice("found proper default implementation attribute but then failed to read it.");
      }
    }
    
    private get_trait_method_attribute(from: IMethod) : Fireball.Internal.TraitMethodAttribute
    {
      def parse_exprs(exprs, acc) : array[string] {
        match(exprs) {
          | PT.PExpr.Literal(Literal.String(val)) :: tail => parse_exprs(tail, val :: acc)
          | _ => acc.Rev().ToArray();
        }
      }
      
      match(from.GetModifiers().FindAttribute(Manager.InternalType.TraitMethodAttribute_tc, GlobalEnv))
      {
        | Some(expr) => match(expr)
          {
            | <[ $_ ([ ..$(wordsList) ])  ]> => match(wordsList)
              {
                | PT.PExpr.Literal(Literal.String(_)) :: _  => 
                  def args = parse_exprs(wordsList, []);
                  Fireball.Internal.TraitMethodAttribute(args)
                | _ => Util.ice("found proper default implementation attribute but then failed to read it.");      
              }                            
            | _ => Util.ice("found proper default implementation attribute but then failed to read it.");      
          }
        | _ => Util.ice("found proper default implementation attribute but then failed to read it.");
      }
    }
    
  }
}
